use std::{fmt::Display, fs::read_to_string, path::{Path, PathBuf}, sync::Arc};

use linked_hash_map::LinkedHashMap;
use pathdiff::diff_paths;
use yaml_rust::{Yaml, YamlLoader};

use crate::{run::{DefaultRunManager, RunError}, task::{from_yaml::InvalidTaskObject, Task, TaskInvocation, TaskRef, Workspace}};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TaskfileId {
    Path(Arc<PathBuf>), // TODO Arc<Path> would be nice
}

impl TaskfileId {
    pub fn from_path(path: impl Into<PathBuf>) -> Self {
        Self::Path(Arc::new(path.into()))
    }

    pub fn display_relative<'a>(&'a self, from: &'a Path) -> impl Display {
        TaskfileIdDisplayRelative(self, from)
    }
}

impl Display for TaskfileId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TaskfileId::Path(path) => path.display().fmt(f),
        }
    }
}

struct TaskfileIdDisplayRelative<'a>(&'a TaskfileId, &'a Path);

impl Display for TaskfileIdDisplayRelative<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.0 {
            TaskfileId::Path(path) => {
                let rel_workdir = diff_paths(
                        path.as_ref(),
                        self.1,
                    )
                    .unwrap_or_else(|| path.as_ref().to_path_buf());
                let rel_workdir = rel_workdir
                    .parent()
                    .unwrap_or("".as_ref());
                rel_workdir.display().fmt(f)
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TaskfileImportRef {
    Resolved(TaskfileId),
    Unresolved(PathBuf),
}

/// Represents a collection of tasks, usually loaded from a taskfile
#[derive(Debug, Clone)]
pub struct Taskfile {
    /// The path that generated this collection of tasks
    ///
    /// This is used to identify the taskfile for multi-taskfile projects
    pub id: TaskfileId,
    pub dir: PathBuf,

    pub imports: LinkedHashMap<String, TaskfileImportRef>,

    /// The tasks in this collection, keyed by their names
    pub tasks: LinkedHashMap<String, Task>,
}

impl Taskfile {
    pub fn new(
        id: TaskfileId,
    ) -> Self {
        let dir = match &id {
            TaskfileId::Path(path) => {
                assert!(path.is_file(), "Path must point to a file");
                path.parent().expect("Taskfile must have a parent directory").to_path_buf()
            },
        };

        Self {
            id,
            dir,
            imports: Default::default(),
            tasks: Default::default(),
        }
    }

    /// Finds the taskfile in the current directory or any parent directory
    pub fn find_taskfile(from: impl AsRef<Path>) -> Option<PathBuf> {
        let mut path = from.as_ref().to_path_buf();
        if path.is_file() {
            return Some(path);
        }
        loop {
            let file_path = path.join("tasks.yaml");
            if file_path.is_file() {
                break Some(file_path);
            }

            // Try to find another "task.*" file that is executable, because taskfiles
            // can be be generated by other tools, for example tasks.json, task.sh, etc.
            //for entry in std::fs::read_dir(&dir).expect("Failed to read directory") {
            //    let entry = entry.expect("Failed to read directory entry");
            //    if entry.file_name().to_string_lossy().starts_with("task.")
            //        && entry.file_type().expect("Failed to get file type").is_file()
            //        && entry.metadata().expect("Failed to get metadata").permissions().mode() & 0o1 != 0
            //    {
            //        todo!()
            //    }
            //}

            if !path.pop() {
                break None;
            }
        }
    }

    pub fn from_yaml_file(taskfile: impl AsRef<Path>) -> Result<Self, YamlLoadError> {
        let taskfile = taskfile.as_ref();
        let taskfile_dir = taskfile
            .parent()
            .ok_or(YamlLoadError::NoParentDirectory(taskfile.to_path_buf()))?;

        let mut this = Self::new(TaskfileId::from_path(taskfile));

        let docs = YamlLoader::load_from_str(
            &read_to_string(taskfile).map_err(YamlLoadError::FileReadError)?,
        )?;

        for doc in docs {
            let doc = doc
                .as_hash()
                .ok_or(YamlDocumentFormatError::DocumentIsNotHash)?;

            if let Some(imports) = doc.get(&Yaml::String("imports".into())) {
                let imports = imports
                    .as_hash()
                    .ok_or(YamlDocumentFormatError::InvalidImportType)?;
                for (key, value) in imports {
                    let key = key
                        .as_str()
                        .ok_or_else(|| YamlDocumentFormatError::InvalidImportKey(key.clone()))?;
                    let import_path = value
                        .as_str()
                        .ok_or_else(|| YamlDocumentFormatError::InvalidImportValue(value.clone()))?;
                    let import_path = PathBuf::from(import_path);
                    let import_path = if import_path.is_absolute() {
                        import_path.clone()
                    } else {
                        taskfile_dir.join(import_path)
                    };
                    this.imports.insert(key.to_string(), TaskfileImportRef::Unresolved(import_path));
                }
            }

            let tasks = doc
                .get(&Yaml::String("tasks".into()))
                .ok_or(YamlDocumentFormatError::MissingTasksKey)?
                .as_hash()
                .ok_or(YamlDocumentFormatError::InvalidTasksType)?;

            for (key, value) in tasks {
                let key = key
                    .as_str()
                    .ok_or_else(|| YamlDocumentFormatError::InvalidTaskKey(key.clone()))?;
                let task = Task::from_yaml(&this.dir, key, value)
                    .map_err(|e| YamlDocumentFormatError::InvalidTaskObject(key.to_string(), e))?;
                this.tasks.insert(key.to_string(), task.clone());
            }
        }

        Ok(this)
    }

    pub fn invoke(&self, workspace: &Workspace, req: &TaskInvocation<TaskRef>) -> Result<(), RunError> {
        crate::run::run(workspace, &self, req, DefaultRunManager)
    }

    pub fn clean(&self, workspace: &Workspace, req: &TaskInvocation<TaskRef>, recursive: bool) -> Result<(), RunError> {
        if recursive {
            crate::run::clean(workspace, &self, req)
        } else {
            crate::run::clean_only(workspace, self, req)
        }
    }
}

#[derive(Debug)]
#[derive(thiserror::Error)]
pub enum YamlLoadError {
    #[error("Failed to parse YAML: {0}")]
    YamlParseError(#[from] yaml_rust::ScanError),
    #[error("Failed to read YAML file: {0}")]
    NoParentDirectory(PathBuf),
    #[error("Failed to read YAML file: {0}")]
    FileReadError(std::io::Error),
    #[error("Invalid YAML document: {0}")]
    Format(#[from] YamlDocumentFormatError),
}

#[derive(Debug, thiserror::Error)]
pub enum YamlDocumentFormatError {
    #[error("Document is not a map")]
    DocumentIsNotHash,
    #[error("Invalid import object, expected a map")]
    InvalidImportType,
    #[error("Invalid import key, should be a string but got: {0:?}")]
    InvalidImportKey(Yaml),
    #[error("Invalid import value, expected a path but got: {0:?}")]
    InvalidImportValue(Yaml),
    #[error("Missing 'tasks' key in the document")]
    MissingTasksKey,
    #[error("Invalid `tasks` object, expected a map")]
    InvalidTasksType,
    #[error("Invalid task key, expected a string but got: {0:?}")]
    InvalidTaskKey(Yaml),
    #[error("Invalid task object for `{0}`: {1}")]
    InvalidTaskObject(String, InvalidTaskObject),
}