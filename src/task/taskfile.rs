use core::panic;
use std::{fmt::Display, fs::read_to_string, os::unix::fs::PermissionsExt, path::{Path, PathBuf}, sync::Arc};

use linked_hash_map::LinkedHashMap;
use pathdiff::diff_paths;
use yaml_rust::{Yaml, YamlLoader};

use crate::{cli::CliRunOptions, run::{DefaultRunManager, RunError}, task::{from_yaml::InvalidTaskObject, Task, TaskInvocation, TaskRef, Workspace, WorkspaceLoadError}};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TaskfileId {
    Path(Arc<PathBuf>), // TODO Arc<Path> would be nice
}

impl TaskfileId {
    pub fn from_path(path: impl Into<PathBuf>) -> Self {
        Self::Path(Arc::new(path.into()))
    }

    pub fn display_relative<'a>(&'a self, from: &'a Path) -> impl Display {
        TaskfileIdDisplayRelative(self, from)
    }
}

impl Display for TaskfileId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TaskfileId::Path(path) => path.display().fmt(f),
        }
    }
}

struct TaskfileIdDisplayRelative<'a>(&'a TaskfileId, &'a Path);

impl Display for TaskfileIdDisplayRelative<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.0 {
            TaskfileId::Path(path) => {
                let rel_workdir = diff_paths(
                        path.as_ref(),
                        self.1,
                    )
                    .unwrap_or_else(|| path.as_ref().to_path_buf());
                let rel_workdir = rel_workdir
                    .parent()
                    .unwrap_or("".as_ref());
                rel_workdir.display().fmt(f)
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TaskfileImportRef {
    Resolved(TaskfileId),
    Unresolved(PathBuf),
}

/// Represents a collection of tasks, usually loaded from a taskfile
#[derive(Debug, Clone)]
pub struct Taskfile {
    /// The path that generated this collection of tasks
    ///
    /// This is used to identify the taskfile for multi-taskfile projects
    pub id: TaskfileId,
    pub dir: PathBuf,

    pub imports: LinkedHashMap<String, TaskfileImportRef>,

    /// The tasks in this collection, keyed by their names
    pub tasks: LinkedHashMap<String, Task>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TaskfileSource {
    /// A taskfile loaded from a YAML file
    YamlFile(PathBuf),
    /// A taskfile YAML data generated by a system command
    Executable(PathBuf),
}

impl TaskfileSource {
    pub fn path(&self) -> &Path {
        match self {
            TaskfileSource::YamlFile(path) => path.as_path(),
            TaskfileSource::Executable(path) => path.as_path(),
        }
    }

    // TODO use a more specific error
    pub fn load(&self) -> Result<Taskfile, WorkspaceLoadError> {
        match self {
            Self::YamlFile(path) => Taskfile::from_yaml_file(&path)
                .map_err(|e| WorkspaceLoadError::Yaml(path.clone(), e)),
            Self::Executable(executable) => {
                Taskfile::from_executable(executable)
                    .map_err(|e| WorkspaceLoadError::Yaml(executable.clone(), e)) // TODO wrong error
            }
        }
    }
}

impl Taskfile {
    pub fn new(
        id: TaskfileId,
    ) -> Self {
        let dir = match &id {
            TaskfileId::Path(path) => {
                assert!(path.is_file(), "Path must point to a file");
                path.parent().expect("Taskfile must have a parent directory").to_path_buf()
            },
        };

        Self {
            id,
            dir,
            imports: Default::default(),
            tasks: Default::default(),
        }
    }

    /// Finds the taskfile in the current directory or any parent directory
    pub fn find_taskfile(from: impl AsRef<Path>) -> Option<TaskfileSource> {
        const YAML_DATA_EXTENSIONS: &[&str] = &["yml", "yaml", "json"];

        fn maybe_source_from_file(path: &Path, check_stem2: bool) -> Option<TaskfileSource> {
            if !path.is_file() {
                return None;
            }

            if path.extension().map(|ext| YAML_DATA_EXTENSIONS.contains(&ext.to_str().unwrap_or(""))).unwrap_or(false) {
                // TODO error handling with WorkspaceLoadError::Canonicalize
                // TODO maybe canonicalize is not actually needed here, it will be done in workspace.rs anyway
                return Some(TaskfileSource::YamlFile(path.to_path_buf().canonicalize().ok()?));
            }

            // check if it is an executable file in the form <something>.yaml.<ext>
            if let Some(stem) = path.file_stem() {
                let Some(stem) = stem.to_str() else {
                    // TODO error handling
                    panic!("Failed to convert file stem to str: {:?}", stem);
                };

                let is_correct_ext = 'e: {
                    for ext in YAML_DATA_EXTENSIONS {
                        // check if it ends with .yaml.<ext> or .yml.<ext> or .json.<ext>
                        if !(stem.ends_with(ext) && stem.strip_suffix(ext).map(|s| s.ends_with('.')).unwrap_or(false)){
                            continue;
                        }

                        let stem2 = stem.strip_suffix(&format!(".{ext}")).unwrap_or(stem);

                        if check_stem2 && !(stem2 == "task" || stem2 == "tasks") {
                            continue;
                        }

                        break 'e true;
                    }
                    false
                };

                // TODO error handling
                if !is_correct_ext {
                    panic!("incorrect extension for executable taskfile: {:?}", path);
                }

                // check if it is executable
                // TODO error handling
                if !path.metadata().map(|m| m.permissions().mode() & 0o1 != 0).unwrap_or(false) {
                    panic!("File is not executable: {:?}", path);
                }

                // TODO assert is file, extension and executable
                // TODO does this apply won windows? Or should we use "start <file>"?
                return Some(TaskfileSource::Executable(path.to_path_buf()));
            }

            // TODO error handling
            panic!("Failed to determine if file is a taskfile: {:?}", path);
        }

        let mut path = from.as_ref().to_path_buf();
        if let Some(source) = maybe_source_from_file(&path, false) {
            return Some(source);
        }
        'l: loop {
            let file_path = path.join("tasks.yaml");
            if let Some(source) = maybe_source_from_file(&file_path, false) {
                break Some(source);
            }

            let file_path = path.join("tasks.yml");
            if let Some(source) = maybe_source_from_file(&file_path, false) {
                break Some(source);
            }

            let file_path = path.join("tasks.json");
            if let Some(source) = maybe_source_from_file(&file_path, false) {
                break Some(source);
            }

            // Try to find another "task.*" file that is executable, because taskfiles
            // can be be generated by other tools, for example tasks.json, task.sh, etc.
            for entry in std::fs::read_dir(&path).expect("Failed to read directory") {
                let entry = entry.expect("Failed to read directory entry");
                // OLD:
                // let name = entry.file_name();
                // let name = name.to_string_lossy();
                // if (name.starts_with("task.yaml") || name.starts_with("task.yml") || name.starts_with("task.json"))
                //     && entry.file_type().expect("Failed to get file type").is_file()
                //     && entry.metadata().expect("Failed to get metadata").permissions().mode() & 0o1 != 0
                if let Some(source) = maybe_source_from_file(&entry.path(), true) {
                    break 'l Some(source);
                }
            }

            if !path.pop() {
                break None;
            }
        }
    }

    pub fn from_yaml_file(taskfile: impl AsRef<Path>) -> Result<Self, YamlLoadError> {
        let taskfile = taskfile.as_ref();
        let taskfile_dir = taskfile
            .parent()
            .ok_or(YamlLoadError::NoParentDirectory(taskfile.to_path_buf()))?;

        let source = read_to_string(taskfile).map_err(YamlLoadError::FileReadError)?;

        Self::from_yaml_source(&source, taskfile, taskfile_dir)
    }

    pub fn from_executable(executable: impl AsRef<Path>) -> Result<Self, YamlLoadError> {
        let executable = executable.as_ref();
        let working_dir = executable
            .parent()
            .ok_or(YamlLoadError::NoParentDirectory(executable.to_path_buf()))?;

        let output = std::process::Command::new(executable)
            .current_dir(working_dir)
            .stdin(std::process::Stdio::null())
            .stderr(std::process::Stdio::inherit())
            .output()
            .map_err(|e| YamlLoadError::ExecutableRunError(executable.to_path_buf(), e))?;

        if !output.status.success() {
            return Err(YamlLoadError::ExecutableRunError(
                executable.to_path_buf(),
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Process exited with code {:?}", output.status.code()),
                ),
            ));
        }

        let source = String::from_utf8(output.stdout)
            .map_err(|e| YamlLoadError::ExecutableOutputNotUtf8(executable.to_path_buf(), e))?;

        Self::from_yaml_source(&source, executable, working_dir)
    }

    pub fn from_yaml_source(source: &str, path: &Path, taskfile_dir: &Path) -> Result<Self, YamlLoadError> {
        let mut this = Self::new(TaskfileId::from_path(path));

        let docs = YamlLoader::load_from_str(source)?;

        for doc in docs {
            let doc = doc
                .as_hash()
                .ok_or(YamlDocumentFormatError::DocumentIsNotHash)?;

            if let Some(imports) = doc.get(&Yaml::String("imports".into())) {
                let imports = imports
                    .as_hash()
                    .ok_or(YamlDocumentFormatError::InvalidImportType)?;
                for (key, value) in imports {
                    let key = key
                        .as_str()
                        .ok_or_else(|| YamlDocumentFormatError::InvalidImportKey(key.clone()))?;
                    let import_path = value
                        .as_str()
                        .ok_or_else(|| YamlDocumentFormatError::InvalidImportValue(value.clone()))?;
                    let import_path = PathBuf::from(import_path);
                    let import_path = if import_path.is_absolute() {
                        import_path.clone()
                    } else {
                        taskfile_dir.join(import_path)
                    };
                    this.imports.insert(key.to_string(), TaskfileImportRef::Unresolved(import_path));
                }
            }

            let tasks = doc
                .get(&Yaml::String("tasks".into()))
                .ok_or(YamlDocumentFormatError::MissingTasksKey)?
                .as_hash()
                .ok_or(YamlDocumentFormatError::InvalidTasksType)?;

            for (key, value) in tasks {
                let key = key
                    .as_str()
                    .ok_or_else(|| YamlDocumentFormatError::InvalidTaskKey(key.clone()))?;
                let task = Task::from_yaml(&this.dir, key, value)
                    .map_err(|e| YamlDocumentFormatError::InvalidTaskObject(key.to_string(), e))?;
                this.tasks.insert(key.to_string(), task.clone());
            }
        }

        Ok(this)
    }

    pub fn invoke(&self, workspace: &Workspace, req: &TaskInvocation<TaskRef>, options: &CliRunOptions) -> Result<(), RunError> {
        crate::run::run(workspace, &self, req, DefaultRunManager(options))
    }

    pub fn clean(&self, workspace: &Workspace, req: &TaskInvocation<TaskRef>, recursive: bool) -> Result<(), RunError> {
        if recursive {
            crate::run::clean(workspace, &self, req)
        } else {
            crate::run::clean_only(workspace, self, req)
        }
    }
}

#[derive(Debug)]
#[derive(thiserror::Error)]
pub enum YamlLoadError {
    #[error("Failed to parse YAML: {0}")]
    YamlParseError(#[from] yaml_rust::ScanError),
    #[error("Failed to read YAML file: {0}")]
    NoParentDirectory(PathBuf),
    #[error("Executable {0} returned non-zero exit code: {1}")]
    ExecutableRunError(PathBuf, std::io::Error), // TODO not sure if this is a good place for this error
    #[error("Executable {0} output is not valid UTF-8")]
    ExecutableOutputNotUtf8(PathBuf, std::string::FromUtf8Error),
    #[error("Failed to read YAML file: {0}")]
    FileReadError(std::io::Error),
    #[error("Invalid YAML document: {0}")]
    Format(#[from] YamlDocumentFormatError),
}

#[derive(Debug, thiserror::Error)]
pub enum YamlDocumentFormatError {
    #[error("Document is not a map")]
    DocumentIsNotHash,
    #[error("Invalid import object, expected a map")]
    InvalidImportType,
    #[error("Invalid import key, should be a string but got: {0:?}")]
    InvalidImportKey(Yaml),
    #[error("Invalid import value, expected a path but got: {0:?}")]
    InvalidImportValue(Yaml),
    #[error("Missing 'tasks' key in the document")]
    MissingTasksKey,
    #[error("Invalid `tasks` object, expected a map")]
    InvalidTasksType,
    #[error("Invalid task key, expected a string but got: {0:?}")]
    InvalidTaskKey(Yaml),
    #[error("Invalid task object for `{0}`: {1}")]
    InvalidTaskObject(String, InvalidTaskObject),
}