use std::{fmt::Display, path::{Path, PathBuf}, sync::Arc};

use linked_hash_map::LinkedHashMap;
use pathdiff::diff_paths;
use yaml_rust::{Yaml, YamlLoader};

use crate::task::{Task, TaskInvocation, TaskRef, Workspace};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TaskfileId {
    Path(Arc<PathBuf>), // TODO Arc<Path> would be nice
}

impl TaskfileId {
    pub fn from_path(path: impl Into<PathBuf>) -> Self {
        Self::Path(Arc::new(path.into()))
    }

    pub fn display_relative<'a>(&'a self, from: &'a Path) -> impl Display {
        TaskfileIdDisplayRelative(self, from)
    }
}

impl Display for TaskfileId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TaskfileId::Path(path) => path.display().fmt(f),
        }
    }
}

struct TaskfileIdDisplayRelative<'a>(&'a TaskfileId, &'a Path);

impl Display for TaskfileIdDisplayRelative<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.0 {
            TaskfileId::Path(path) => {
                let rel_workdir = diff_paths(
                        path.as_ref(),
                        self.1,
                    )
                    .unwrap_or_else(|| path.as_ref().to_path_buf());
                let rel_workdir = rel_workdir
                    .parent()
                    .unwrap_or("".as_ref());
                rel_workdir.display().fmt(f)
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TaskfileImportRef {
    Resolved(TaskfileId),
    Unresolved(PathBuf),
}

/// Represents a collection of tasks, usually loaded from a taskfile
#[derive(Debug, Clone)]
pub struct Taskfile {
    /// The path that generated this collection of tasks
    ///
    /// This is used to identify the taskfile for multi-taskfile projects
    pub id: TaskfileId,
    pub dir: PathBuf,

    pub imports: LinkedHashMap<String, TaskfileImportRef>,

    /// The tasks in this collection, keyed by their names
    pub tasks: LinkedHashMap<String, Task>,
}

impl Taskfile {
    pub fn new(
        id: TaskfileId,
    ) -> Self {
        let dir = match &id {
            TaskfileId::Path(path) => {
                assert!(path.is_file(), "Path must point to a file");
                path.parent().expect("Taskfile must have a parent directory").to_path_buf()
            },
        };

        Self {
            id,
            dir,
            imports: Default::default(),
            tasks: Default::default(),
        }
    }

    /// Finds the taskfile in the current directory or any parent directory
    pub fn find_taskfile(from: impl AsRef<Path>) -> PathBuf {
        let mut path = from.as_ref().to_path_buf();
        if path.is_file() {
            return path;
        }
        loop {
            let file_path = path.join("tasks.yaml");
            if file_path.is_file() {
                break file_path;
            }

            // Try to find another "task.*" file that is executable, because taskfiles
            // can be be generated by other tools, for example tasks.json, task.sh, etc.
            //for entry in std::fs::read_dir(&dir).expect("Failed to read directory") {
            //    let entry = entry.expect("Failed to read directory entry");
            //    if entry.file_name().to_string_lossy().starts_with("task.")
            //        && entry.file_type().expect("Failed to get file type").is_file()
            //        && entry.metadata().expect("Failed to get metadata").permissions().mode() & 0o1 != 0
            //    {
            //        todo!()
            //    }
            //}

            if !path.pop() {
                panic!("No 'tasks.yaml' found in the current directory or any parent directory");
            }
        }
    }

    pub fn parse_yaml(taskfile: impl AsRef<Path>) -> Self {
        let taskfile = taskfile.as_ref();
        let taskfile_dir = taskfile.parent().expect("Taskfile must have a parent directory");

        let mut this = Self::new(TaskfileId::from_path(taskfile));

        let docs = YamlLoader::load_from_str(
            &std::fs::read_to_string(taskfile).expect("Failed to read 'tasks.yaml' file"),
        )
        .unwrap();

        for doc in docs {
            let doc = doc.as_hash().expect("Expected a YAML hash");

            if let Some(imports) = doc.get(&Yaml::String("imports".into())) {
                let imports = imports.as_hash().expect("Expected 'imports' to be a hash");
                for (key, value) in imports {
                    let key = key.as_str().expect("Expected import key to be a string");
                    let import_path = value.as_str().expect("Expected import value to be a string");
                    let import_path = PathBuf::from(import_path);
                    let import_path = if import_path.is_absolute() {
                        import_path.clone()
                    } else {
                        taskfile_dir.join(import_path)
                    };
                    this.imports.insert(key.to_string(), TaskfileImportRef::Unresolved(import_path));
                }
            }

            let tasks = doc
                .get(&Yaml::String("tasks".into()))
                .expect("Expected 'tasks' key")
                .as_hash()
                .expect("Expected 'tasks' to be a hash");

            for (key, value) in tasks {
                let key = key.as_str().expect("Expected task key to be a string");
                let task = Task::from_yaml(&taskfile.parent().unwrap(), key, value);
                this.tasks.insert(key.to_string(), task.clone());
            }
        }

        this
    }

    pub fn invoke(&self, workspace: &Workspace, req: &TaskInvocation<TaskRef>) {
        crate::run::run(workspace, &self, req);
    }

    pub fn clean(&self, workspace: &Workspace, req: &TaskInvocation<TaskRef>, recursive: bool) {
        if recursive {
            crate::run::clean(workspace, &self, req);
        } else {
            crate::run::clean_only(workspace, self, req);
        }
    }
}