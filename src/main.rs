use std::path::{Path, PathBuf};

use birb_run::task::{TaskInvocation, Tasks};
use clap::Parser;

#[derive(Parser, Debug)]
#[clap(styles = cli_styles::CLAP_STYLES)]
enum Cli {
    Run(Run),
    Clean(Clean),
    CleanOnly(CleanOnly),
}

/// Run a task
#[derive(Parser, Debug)]
struct Run {
    task: String,
}

/// Recursively clean a task
#[derive(Parser, Debug)]
struct Clean {
    task: String,
}

/// Clean a single task (non recursive)
#[derive(Parser, Debug)]
struct CleanOnly {
    task: String,
}

fn main() {
    env_logger::init();

    let args = Cli::parse();

    let cwd = std::env::current_dir().expect("Failed to get current directory");

    let taskfile_path = find_taskfile(&cwd);
    let tasks = Tasks::load_yaml_taskfile(&taskfile_path);

    match args {
        Cli::Run(args) => {
            tasks.invoke(&TaskInvocation::no_args(args.task));
        }
        Cli::Clean(args) => {
            tasks.clean(&TaskInvocation::no_args(args.task), true);
        },
        Cli::CleanOnly(args) => {
            tasks.clean(&TaskInvocation::no_args(args.task), false);
        }
    }
}

fn find_taskfile(from: impl AsRef<Path>) -> PathBuf {
    let mut dir = from.as_ref().to_path_buf();
        loop {
            let path = dir.join("tasks.yaml");
            if path.is_file() {
                break path;
            }

            // Try to find another "task.*" file that is executable, because taskfiles
            // can be be generated by other tools, for example tasks.json, task.sh, etc.
            //for entry in std::fs::read_dir(&dir).expect("Failed to read directory") {
            //    let entry = entry.expect("Failed to read directory entry");
            //    if entry.file_name().to_string_lossy().starts_with("task.")
            //        && entry.file_type().expect("Failed to get file type").is_file()
            //        && entry.metadata().expect("Failed to get metadata").permissions().mode() & 0o1 != 0
            //    {
            //        todo!()
            //    }
            //}

            if !dir.pop() {
                panic!("No 'tasks.yaml' found in the current directory or any parent directory");
            }
        }
}